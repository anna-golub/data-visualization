# -*- coding: utf-8 -*-
"""4_seaborn_plotly.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G-ECQi37-dRqald00oiFgURn-UM_PbL3

Загружаем необходимые библиотеки и сами данные
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/визуализация/Goodreads-books_preprocessed.csv',
                 index_col=0)
df['publication_date'] = pd.to_datetime(df['publication_date'], format='%Y-%m-%d')
df.head()

"""# Гипотезы

1. **Столбцы ratings_count и text_reviews_count достаточно сильно коррелируют.**

Построим диаграмму рассеяния: по x отложим ratings_count, по y - text_reviews_count.
"""

sns.set_theme(style="darkgrid")
plt.plot()
sns.set_color_codes("dark")
sns.scatterplot(data=df, x='ratings_count', y='text_reviews_count', 
             label='average rating distribution', color="b");
plt.legend(ncol=1);
plt.savefig('1.jpg')

"""Дополнительно посчитаем коэффициент корреляции"""

df['ratings_count'].corr(df['text_reviews_count'])

"""Значит, эти столбцы действительно **сильно коррелируют**, и один из них можно удалить. Вероятно, логичнее будет удалить text_reviews_count, так как он напрямую не связан с average_rating."""

df.drop('text_reviews_count', axis=1, inplace=True)

"""2. **Пользователи Goodreads практически не читают книги длиной более 1500 страниц.**

Построим график зависимости числа выставленных книге рейтингов от числа страниц в ней
"""

sns.lineplot(data=df, x='num_pages', y='ratings_count', ci=None);
plt.savefig('2.jpg')

"""Как можно видеть, книгам длиннее 1500 страниц действительно редко ставят оценки на сайте.

3.  **Книги равномерно распределены по годам издания**   
(каждый год, по данным датасета, выходило примерно одинаковое число книг)

Создадим датафрейм, со столбцами "год издания" и "число изданных в этот год книг".
"""

yearly_published = df.groupby(df.publication_date.dt.year)['bookID'].count().to_frame().reset_index()
yearly_published.columns = ['year', 'books_published']
yearly_published.head()

"""Визуализируем полученные данные"""

fig = px.line(yearly_published, x='year', y='books_published', 
              title='Number of books published over years')
fig.update_xaxes(tick0=1900, dtick=10)
fig.show()

"""Оказывается, записи в датасете **неравномерно** распределены по датам публикации. Подавляющее большинство книг вышло в промежуток с **1975** по **2007** год.

4. **Большинство книг написаны одним или двумя авторами.**

Создадим датафрейм со столбцами "число авторов" и "сколько книг написано таким числом авторов" и отсортируем его по убыванию значений второго столбца.
"""

authors_number_count = df.groupby('authors_number')['bookID'].count() \
  .to_frame().reset_index().sort_values(by='bookID', ascending=False)
authors_number_count.columns = ['authors_number', 'books_count']
authors_number_count = authors_number_count.head(5)

"""Отобразим первые пять строк датафрейма на гистограмме."""

sns.set_theme(style="darkgrid")
plt.plot()
sns.set_color_codes("dark")
sns.barplot(data=authors_number_count, x='authors_number', y='books_count', 
            label = 'books count', color='b');
plt.legend(ncol=1);
plt.savefig('4.jpg')

"""Таким образом, гипотеза подтверждена.

5. **Средний рейтинг большей части книг лежит в промежутке от 3 до 5.**

Построим гистограмму распределения среднего рейтинга книг.
"""

sns.set_theme(style="darkgrid")
plt.plot()
sns.set_color_codes("dark")
sns.histplot(data=df, x='average_rating', 
             label='average rating', binwidth=0.15, color="b");
plt.legend(ncol=1);
plt.savefig('5.jpg')

"""Как и предыдущая, гипотеза оказалась верной."""